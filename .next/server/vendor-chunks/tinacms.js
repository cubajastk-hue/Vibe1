"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tinacms";
exports.ids = ["vendor-chunks/tinacms"];
exports.modules = {

/***/ "(rsc)/./node_modules/tinacms/dist/client.js":
/*!*********************************************!*\
  !*** ./node_modules/tinacms/dist/client.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TINA_HOST: () => (/* binding */ TINA_HOST),\n/* harmony export */   TinaClient: () => (/* binding */ TinaClient),\n/* harmony export */   createClient: () => (/* binding */ createClient)\n/* harmony export */ });\n/* harmony import */ var async_lock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! async-lock */ \"(rsc)/./node_modules/async-lock/index.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/cache/node-cache.ts\nvar node_cache_exports = {};\n__export(node_cache_exports, {\n  NodeCache: () => NodeCache,\n  makeCacheDir: () => makeCacheDir\n});\nvar resolveModule, getRootPath, makeCacheDir, NodeCache;\nvar init_node_cache = __esm({\n  \"src/cache/node-cache.ts\"() {\n    resolveModule = (mod) => {\n      if (mod && typeof mod === \"object\" && \"default\" in mod && mod.default) {\n        return mod.default;\n      }\n      return mod;\n    };\n    getRootPath = (pathParts, pathArg) => {\n      if (pathParts.length === 0) return null;\n      const isWindows = pathArg.sep === \"\\\\\";\n      const root = pathParts[0];\n      return isWindows ? `${root}${pathArg.sep}` : `${pathArg.sep}${root}`;\n    };\n    makeCacheDir = (dir, fsArg, pathArg, osArg) => {\n      const normalizedDir = pathArg.normalize(dir);\n      const pathParts = normalizedDir.split(pathArg.sep).filter(Boolean);\n      const cacheHash = pathParts[pathParts.length - 1];\n      const rootPath = getRootPath(pathParts, pathArg);\n      const rootExists = rootPath && fsArg.existsSync(rootPath);\n      const cacheDir = rootExists ? normalizedDir : pathArg.join(osArg.tmpdir(), cacheHash);\n      try {\n        fsArg.mkdirSync(cacheDir, { recursive: true });\n      } catch (error) {\n        console.warn(\n          `Warning: Failed to create cache directory: ${error.message}. Caching will be disabled.`\n        );\n        return null;\n      }\n      return cacheDir;\n    };\n    NodeCache = async (dir) => {\n      try {\n        const [fsModule, pathModule, osModule, cryptoModule] = await Promise.all([\n          Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:fs */ \"node:fs\", 19)),\n          Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:path */ \"node:path\", 19)),\n          Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:os */ \"node:os\", 19)),\n          Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:crypto */ \"node:crypto\", 19))\n        ]);\n        const fs = resolveModule(fsModule);\n        const path = resolveModule(pathModule);\n        const os = resolveModule(osModule);\n        const crypto = resolveModule(cryptoModule);\n        if (typeof path?.join !== \"function\") {\n          console.warn(\n            \"Warning: Node.js path module not available. Caching will be disabled.\"\n          );\n          return null;\n        }\n        const cacheDir = makeCacheDir(dir, fs, path, os);\n        if (cacheDir === null) {\n          return null;\n        }\n        return {\n          makeKey: (key) => {\n            const input = key && key instanceof Object ? JSON.stringify(key) : key || \"\";\n            return crypto.createHash(\"sha256\").update(input).digest(\"hex\");\n          },\n          get: async (key) => {\n            let readValue;\n            const cacheFilename = path.join(cacheDir, key);\n            try {\n              const data = await fs.promises.readFile(cacheFilename, \"utf-8\");\n              readValue = JSON.parse(data);\n            } catch (e) {\n              if (e.code !== \"ENOENT\") {\n                console.warn(\n                  `Warning: Failed to read cache file ${cacheFilename}: ${e.message}`\n                );\n              }\n            }\n            return readValue;\n          },\n          set: async (key, value) => {\n            const cacheFilename = path.join(cacheDir, key);\n            try {\n              await fs.promises.writeFile(cacheFilename, JSON.stringify(value), {\n                encoding: \"utf-8\",\n                flag: \"wx\"\n              });\n            } catch (e) {\n              if (e.code !== \"EEXIST\") {\n                console.warn(\n                  `Warning: Failed to write cache file ${cacheFilename}: ${e.message}`\n                );\n              }\n            }\n          }\n        };\n      } catch (e) {\n        console.warn(\n          \"Warning: Failed to initialize cache. Caching will be disabled.\",\n          e.message\n        );\n        return null;\n      }\n    };\n  }\n});\n\n// src/unifiedClient/index.ts\n\nvar TINA_HOST = \"content.tinajs.io\";\nfunction replaceGithubPathSplit(url, replacement) {\n  const parts = url.split(\"github/\");\n  if (parts.length > 1 && replacement) {\n    return parts[0] + \"github/\" + replacement;\n  } else {\n    return url;\n  }\n}\nvar TinaClient = class {\n  apiUrl;\n  readonlyToken;\n  queries;\n  errorPolicy;\n  initialized = false;\n  cacheLock;\n  cacheDir;\n  cache;\n  constructor({\n    token,\n    url,\n    queries,\n    errorPolicy,\n    cacheDir\n  }) {\n    this.apiUrl = url;\n    this.readonlyToken = token?.trim();\n    this.queries = queries(this);\n    this.errorPolicy = errorPolicy || \"throw\";\n    this.cacheDir = cacheDir || \"\";\n  }\n  async init() {\n    if (this.initialized) {\n      return;\n    }\n    try {\n      if (this.cacheDir && typeof window === \"undefined\") {\n        const { NodeCache: NodeCache2 } = await Promise.resolve().then(() => (init_node_cache(), node_cache_exports));\n        this.cache = await NodeCache2(this.cacheDir);\n        if (this.cache) {\n          this.cacheLock = new async_lock__WEBPACK_IMPORTED_MODULE_0__();\n        }\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    this.initialized = true;\n  }\n  async request({ errorPolicy, ...args }, options) {\n    await this.init();\n    const errorPolicyDefined = errorPolicy || this.errorPolicy;\n    const headers = new Headers();\n    if (this.readonlyToken) {\n      headers.append(\"X-API-KEY\", this.readonlyToken);\n    }\n    headers.append(\"Content-Type\", \"application/json\");\n    if (options?.fetchOptions) {\n      if (options?.fetchOptions?.headers) {\n        Object.entries(options.fetchOptions.headers).forEach(([key2, value]) => {\n          headers.append(key2, value);\n        });\n      }\n    }\n    const { headers: _, ...providedFetchOptions } = options?.fetchOptions || {};\n    const bodyString = JSON.stringify({\n      query: args.query,\n      variables: args?.variables || {}\n    });\n    const optionsObject = {\n      method: \"POST\",\n      headers,\n      body: bodyString,\n      redirect: \"follow\",\n      ...providedFetchOptions\n    };\n    const draftBranch = headers.get(\"x-branch\");\n    const url = replaceGithubPathSplit(args?.url || this.apiUrl, draftBranch);\n    let key = \"\";\n    let result;\n    if (this.cache) {\n      key = this.cache.makeKey(bodyString);\n      await this.cacheLock.acquire(key, async () => {\n        result = await this.cache.get(key);\n        if (!result) {\n          result = await requestFromServer(\n            url,\n            args.query,\n            optionsObject,\n            errorPolicyDefined\n          );\n          await this.cache.set(key, result);\n        }\n      });\n    } else {\n      result = await requestFromServer(\n        url,\n        args.query,\n        optionsObject,\n        errorPolicyDefined\n      );\n    }\n    return result;\n  }\n};\nasync function requestFromServer(url, query, optionsObject, errorPolicyDefined) {\n  const res = await fetch(url, optionsObject);\n  if (!res.ok) {\n    let additionalInfo = \"\";\n    if (res.status === 401) {\n      additionalInfo = \"Please check that your client ID, URL and read only token are configured properly.\";\n    }\n    throw new Error(\n      `Server responded with status code ${res.status}, ${res.statusText}. ${additionalInfo ? additionalInfo : \"\"} Please see our FAQ for more information: https://tina.io/docs/r/FAQ/`\n    );\n  }\n  const json = await res.json();\n  if (json.errors && errorPolicyDefined === \"throw\") {\n    throw new Error(\n      `Unable to fetch, please see our FAQ for more information: https://tina.io/docs/r/FAQ/\n      Errors: \n\t${json.errors.map((error) => error.message).join(\"\\n\")}`\n    );\n  }\n  const result = {\n    data: json?.data,\n    errors: json?.errors || null,\n    query\n  };\n  return result;\n}\nfunction createClient(args) {\n  const client = new TinaClient(args);\n  return client;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGluYWNtcy9kaXN0L2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSyxFQUFFLFlBQVksT0FBTyxZQUFZLEVBQUUsS0FBSztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JELFFBQVE7QUFDUjtBQUNBLHdEQUF3RCxjQUFjO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9IQUFpQjtBQUMzQixVQUFVLHdIQUFtQjtBQUM3QixVQUFVLG9IQUFpQjtBQUMzQixVQUFVLDRIQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHdEQUF3RCxjQUFjLElBQUksVUFBVTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQSx5REFBeUQsY0FBYyxJQUFJLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQSwrQkFBK0IsdUNBQVM7QUFDeEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVcsSUFBSSxlQUFlLElBQUksc0NBQXNDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxxREFBcUQ7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLRSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtd2ViLy4vbm9kZV9tb2R1bGVzL3RpbmFjbXMvZGlzdC9jbGllbnQuanM/NjMxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19lc20gPSAoZm4sIHJlcykgPT4gZnVuY3Rpb24gX19pbml0KCkge1xuICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltfX2dldE93blByb3BOYW1lcyhmbilbMF1dKShmbiA9IDApKSwgcmVzO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2NhY2hlL25vZGUtY2FjaGUudHNcbnZhciBub2RlX2NhY2hlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5vZGVfY2FjaGVfZXhwb3J0cywge1xuICBOb2RlQ2FjaGU6ICgpID0+IE5vZGVDYWNoZSxcbiAgbWFrZUNhY2hlRGlyOiAoKSA9PiBtYWtlQ2FjaGVEaXJcbn0pO1xudmFyIHJlc29sdmVNb2R1bGUsIGdldFJvb3RQYXRoLCBtYWtlQ2FjaGVEaXIsIE5vZGVDYWNoZTtcbnZhciBpbml0X25vZGVfY2FjaGUgPSBfX2VzbSh7XG4gIFwic3JjL2NhY2hlL25vZGUtY2FjaGUudHNcIigpIHtcbiAgICByZXNvbHZlTW9kdWxlID0gKG1vZCkgPT4ge1xuICAgICAgaWYgKG1vZCAmJiB0eXBlb2YgbW9kID09PSBcIm9iamVjdFwiICYmIFwiZGVmYXVsdFwiIGluIG1vZCAmJiBtb2QuZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gbW9kLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kO1xuICAgIH07XG4gICAgZ2V0Um9vdFBhdGggPSAocGF0aFBhcnRzLCBwYXRoQXJnKSA9PiB7XG4gICAgICBpZiAocGF0aFBhcnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBpc1dpbmRvd3MgPSBwYXRoQXJnLnNlcCA9PT0gXCJcXFxcXCI7XG4gICAgICBjb25zdCByb290ID0gcGF0aFBhcnRzWzBdO1xuICAgICAgcmV0dXJuIGlzV2luZG93cyA/IGAke3Jvb3R9JHtwYXRoQXJnLnNlcH1gIDogYCR7cGF0aEFyZy5zZXB9JHtyb290fWA7XG4gICAgfTtcbiAgICBtYWtlQ2FjaGVEaXIgPSAoZGlyLCBmc0FyZywgcGF0aEFyZywgb3NBcmcpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWREaXIgPSBwYXRoQXJnLm5vcm1hbGl6ZShkaXIpO1xuICAgICAgY29uc3QgcGF0aFBhcnRzID0gbm9ybWFsaXplZERpci5zcGxpdChwYXRoQXJnLnNlcCkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgY29uc3QgY2FjaGVIYXNoID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IHJvb3RQYXRoID0gZ2V0Um9vdFBhdGgocGF0aFBhcnRzLCBwYXRoQXJnKTtcbiAgICAgIGNvbnN0IHJvb3RFeGlzdHMgPSByb290UGF0aCAmJiBmc0FyZy5leGlzdHNTeW5jKHJvb3RQYXRoKTtcbiAgICAgIGNvbnN0IGNhY2hlRGlyID0gcm9vdEV4aXN0cyA/IG5vcm1hbGl6ZWREaXIgOiBwYXRoQXJnLmpvaW4ob3NBcmcudG1wZGlyKCksIGNhY2hlSGFzaCk7XG4gICAgICB0cnkge1xuICAgICAgICBmc0FyZy5ta2RpclN5bmMoY2FjaGVEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBXYXJuaW5nOiBGYWlsZWQgdG8gY3JlYXRlIGNhY2hlIGRpcmVjdG9yeTogJHtlcnJvci5tZXNzYWdlfS4gQ2FjaGluZyB3aWxsIGJlIGRpc2FibGVkLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVEaXI7XG4gICAgfTtcbiAgICBOb2RlQ2FjaGUgPSBhc3luYyAoZGlyKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbZnNNb2R1bGUsIHBhdGhNb2R1bGUsIG9zTW9kdWxlLCBjcnlwdG9Nb2R1bGVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIGltcG9ydChcIm5vZGU6ZnNcIiksXG4gICAgICAgICAgaW1wb3J0KFwibm9kZTpwYXRoXCIpLFxuICAgICAgICAgIGltcG9ydChcIm5vZGU6b3NcIiksXG4gICAgICAgICAgaW1wb3J0KFwibm9kZTpjcnlwdG9cIilcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGZzID0gcmVzb2x2ZU1vZHVsZShmc01vZHVsZSk7XG4gICAgICAgIGNvbnN0IHBhdGggPSByZXNvbHZlTW9kdWxlKHBhdGhNb2R1bGUpO1xuICAgICAgICBjb25zdCBvcyA9IHJlc29sdmVNb2R1bGUob3NNb2R1bGUpO1xuICAgICAgICBjb25zdCBjcnlwdG8gPSByZXNvbHZlTW9kdWxlKGNyeXB0b01vZHVsZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aD8uam9pbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJXYXJuaW5nOiBOb2RlLmpzIHBhdGggbW9kdWxlIG5vdCBhdmFpbGFibGUuIENhY2hpbmcgd2lsbCBiZSBkaXNhYmxlZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVEaXIgPSBtYWtlQ2FjaGVEaXIoZGlyLCBmcywgcGF0aCwgb3MpO1xuICAgICAgICBpZiAoY2FjaGVEaXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1ha2VLZXk6IChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0ga2V5ICYmIGtleSBpbnN0YW5jZW9mIE9iamVjdCA/IEpTT04uc3RyaW5naWZ5KGtleSkgOiBrZXkgfHwgXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUoaW5wdXQpLmRpZ2VzdChcImhleFwiKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldDogYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlYWRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRmlsZW5hbWUgPSBwYXRoLmpvaW4oY2FjaGVEaXIsIGtleSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUoY2FjaGVGaWxlbmFtZSwgXCJ1dGYtOFwiKTtcbiAgICAgICAgICAgICAgcmVhZFZhbHVlID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUuY29kZSAhPT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIGBXYXJuaW5nOiBGYWlsZWQgdG8gcmVhZCBjYWNoZSBmaWxlICR7Y2FjaGVGaWxlbmFtZX06ICR7ZS5tZXNzYWdlfWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVhZFZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBhc3luYyAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVGaWxlbmFtZSA9IHBhdGguam9pbihjYWNoZURpciwga2V5KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IGZzLnByb21pc2VzLndyaXRlRmlsZShjYWNoZUZpbGVuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogXCJ1dGYtOFwiLFxuICAgICAgICAgICAgICAgIGZsYWc6IFwid3hcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUuY29kZSAhPT0gXCJFRVhJU1RcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIGBXYXJuaW5nOiBGYWlsZWQgdG8gd3JpdGUgY2FjaGUgZmlsZSAke2NhY2hlRmlsZW5hbWV9OiAke2UubWVzc2FnZX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiV2FybmluZzogRmFpbGVkIHRvIGluaXRpYWxpemUgY2FjaGUuIENhY2hpbmcgd2lsbCBiZSBkaXNhYmxlZC5cIixcbiAgICAgICAgICBlLm1lc3NhZ2VcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy91bmlmaWVkQ2xpZW50L2luZGV4LnRzXG5pbXBvcnQgQXN5bmNMb2NrIGZyb20gXCJhc3luYy1sb2NrXCI7XG52YXIgVElOQV9IT1NUID0gXCJjb250ZW50LnRpbmFqcy5pb1wiO1xuZnVuY3Rpb24gcmVwbGFjZUdpdGh1YlBhdGhTcGxpdCh1cmwsIHJlcGxhY2VtZW50KSB7XG4gIGNvbnN0IHBhcnRzID0gdXJsLnNwbGl0KFwiZ2l0aHViL1wiKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEgJiYgcmVwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gcGFydHNbMF0gKyBcImdpdGh1Yi9cIiArIHJlcGxhY2VtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbn1cbnZhciBUaW5hQ2xpZW50ID0gY2xhc3Mge1xuICBhcGlVcmw7XG4gIHJlYWRvbmx5VG9rZW47XG4gIHF1ZXJpZXM7XG4gIGVycm9yUG9saWN5O1xuICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICBjYWNoZUxvY2s7XG4gIGNhY2hlRGlyO1xuICBjYWNoZTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRva2VuLFxuICAgIHVybCxcbiAgICBxdWVyaWVzLFxuICAgIGVycm9yUG9saWN5LFxuICAgIGNhY2hlRGlyXG4gIH0pIHtcbiAgICB0aGlzLmFwaVVybCA9IHVybDtcbiAgICB0aGlzLnJlYWRvbmx5VG9rZW4gPSB0b2tlbj8udHJpbSgpO1xuICAgIHRoaXMucXVlcmllcyA9IHF1ZXJpZXModGhpcyk7XG4gICAgdGhpcy5lcnJvclBvbGljeSA9IGVycm9yUG9saWN5IHx8IFwidGhyb3dcIjtcbiAgICB0aGlzLmNhY2hlRGlyID0gY2FjaGVEaXIgfHwgXCJcIjtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5jYWNoZURpciAmJiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnN0IHsgTm9kZUNhY2hlOiBOb2RlQ2FjaGUyIH0gPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IChpbml0X25vZGVfY2FjaGUoKSwgbm9kZV9jYWNoZV9leHBvcnRzKSk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBhd2FpdCBOb2RlQ2FjaGUyKHRoaXMuY2FjaGVEaXIpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgICAgIHRoaXMuY2FjaGVMb2NrID0gbmV3IEFzeW5jTG9jaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdCh7IGVycm9yUG9saWN5LCAuLi5hcmdzIH0sIG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICBjb25zdCBlcnJvclBvbGljeURlZmluZWQgPSBlcnJvclBvbGljeSB8fCB0aGlzLmVycm9yUG9saWN5O1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGlmICh0aGlzLnJlYWRvbmx5VG9rZW4pIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwiWC1BUEktS0VZXCIsIHRoaXMucmVhZG9ubHlUb2tlbik7XG4gICAgfVxuICAgIGhlYWRlcnMuYXBwZW5kKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICBpZiAob3B0aW9ucz8uZmV0Y2hPcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucz8uZmV0Y2hPcHRpb25zPy5oZWFkZXJzKSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuZmV0Y2hPcHRpb25zLmhlYWRlcnMpLmZvckVhY2goKFtrZXkyLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXkyLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGhlYWRlcnM6IF8sIC4uLnByb3ZpZGVkRmV0Y2hPcHRpb25zIH0gPSBvcHRpb25zPy5mZXRjaE9wdGlvbnMgfHwge307XG4gICAgY29uc3QgYm9keVN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHF1ZXJ5OiBhcmdzLnF1ZXJ5LFxuICAgICAgdmFyaWFibGVzOiBhcmdzPy52YXJpYWJsZXMgfHwge31cbiAgICB9KTtcbiAgICBjb25zdCBvcHRpb25zT2JqZWN0ID0ge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBib2R5U3RyaW5nLFxuICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgICAuLi5wcm92aWRlZEZldGNoT3B0aW9uc1xuICAgIH07XG4gICAgY29uc3QgZHJhZnRCcmFuY2ggPSBoZWFkZXJzLmdldChcIngtYnJhbmNoXCIpO1xuICAgIGNvbnN0IHVybCA9IHJlcGxhY2VHaXRodWJQYXRoU3BsaXQoYXJncz8udXJsIHx8IHRoaXMuYXBpVXJsLCBkcmFmdEJyYW5jaCk7XG4gICAgbGV0IGtleSA9IFwiXCI7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAga2V5ID0gdGhpcy5jYWNoZS5tYWtlS2V5KGJvZHlTdHJpbmcpO1xuICAgICAgYXdhaXQgdGhpcy5jYWNoZUxvY2suYWNxdWlyZShrZXksIGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCByZXF1ZXN0RnJvbVNlcnZlcihcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGFyZ3MucXVlcnksXG4gICAgICAgICAgICBvcHRpb25zT2JqZWN0LFxuICAgICAgICAgICAgZXJyb3JQb2xpY3lEZWZpbmVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLmNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCByZXF1ZXN0RnJvbVNlcnZlcihcbiAgICAgICAgdXJsLFxuICAgICAgICBhcmdzLnF1ZXJ5LFxuICAgICAgICBvcHRpb25zT2JqZWN0LFxuICAgICAgICBlcnJvclBvbGljeURlZmluZWRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0RnJvbVNlcnZlcih1cmwsIHF1ZXJ5LCBvcHRpb25zT2JqZWN0LCBlcnJvclBvbGljeURlZmluZWQpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zT2JqZWN0KTtcbiAgaWYgKCFyZXMub2spIHtcbiAgICBsZXQgYWRkaXRpb25hbEluZm8gPSBcIlwiO1xuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgIGFkZGl0aW9uYWxJbmZvID0gXCJQbGVhc2UgY2hlY2sgdGhhdCB5b3VyIGNsaWVudCBJRCwgVVJMIGFuZCByZWFkIG9ubHkgdG9rZW4gYXJlIGNvbmZpZ3VyZWQgcHJvcGVybHkuXCI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggc3RhdHVzIGNvZGUgJHtyZXMuc3RhdHVzfSwgJHtyZXMuc3RhdHVzVGV4dH0uICR7YWRkaXRpb25hbEluZm8gPyBhZGRpdGlvbmFsSW5mbyA6IFwiXCJ9IFBsZWFzZSBzZWUgb3VyIEZBUSBmb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly90aW5hLmlvL2RvY3Mvci9GQVEvYFxuICAgICk7XG4gIH1cbiAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gIGlmIChqc29uLmVycm9ycyAmJiBlcnJvclBvbGljeURlZmluZWQgPT09IFwidGhyb3dcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmFibGUgdG8gZmV0Y2gsIHBsZWFzZSBzZWUgb3VyIEZBUSBmb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly90aW5hLmlvL2RvY3Mvci9GQVEvXG4gICAgICBFcnJvcnM6IFxuXHQke2pzb24uZXJyb3JzLm1hcCgoZXJyb3IpID0+IGVycm9yLm1lc3NhZ2UpLmpvaW4oXCJcXG5cIil9YFxuICAgICk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGRhdGE6IGpzb24/LmRhdGEsXG4gICAgZXJyb3JzOiBqc29uPy5lcnJvcnMgfHwgbnVsbCxcbiAgICBxdWVyeVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KGFyZ3MpIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IFRpbmFDbGllbnQoYXJncyk7XG4gIHJldHVybiBjbGllbnQ7XG59XG5leHBvcnQge1xuICBUSU5BX0hPU1QsXG4gIFRpbmFDbGllbnQsXG4gIGNyZWF0ZUNsaWVudFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tinacms/dist/client.js\n");

/***/ })

};
;